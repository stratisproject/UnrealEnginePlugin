// Copyright Â© 2022 Stratis Platform.
//
// This file is part of Stratis Plugin for Unreal Engine. The full copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

/**
 * Stratis Node API
 * Access to the Stratis Node's api.
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "UnrealApiOperations.h"

#include "Helpers.h"
#include "StratisAPIModule.h"

#include "Dom/JsonObject.h"
#include "HttpModule.h"
#include "PlatformHttp.h"
#include "Templates/SharedPointer.h"

namespace stratis {
namespace api {

FString UnrealApi::Unity3dBlockGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/block"));
    TArray<FString> QueryParams;
    QueryParams.Add(FString(TEXT("Hash=")) + ToUrlString(Hash));
    if (ShowTransactionDetails.IsSet()) {
        QueryParams.Add(FString(TEXT("ShowTransactionDetails=")) + ToUrlString(ShowTransactionDetails.GetValue()));
    }
    if (OutputJson.IsSet()) {
        QueryParams.Add(FString(TEXT("OutputJson=")) + ToUrlString(OutputJson.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dBlockGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dBlockGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dBlockGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dGetAllNftOwnersByContractAddressGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/get-all-nft-owners-by-contract-address"));
    TArray<FString> QueryParams;
    if (ContractAddress.IsSet()) {
        QueryParams.Add(FString(TEXT("contractAddress=")) + ToUrlString(ContractAddress.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dGetAllNftOwnersByContractAddressGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dGetAllNftOwnersByContractAddressGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dGetAllNftOwnersByContractAddressGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dGetOwnedNftsGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/get-owned-nfts"));
    TArray<FString> QueryParams;
    if (OwnerAddress.IsSet()) {
        QueryParams.Add(FString(TEXT("ownerAddress=")) + ToUrlString(OwnerAddress.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dGetOwnedNftsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dGetOwnedNftsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dGetOwnedNftsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dGetWatchedNftContractsGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/get-watched-nft-contracts"));
    return Path;
}

void UnrealApi::Unity3dGetWatchedNftContractsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dGetWatchedNftContractsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dGetWatchedNftContractsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dGetaddressbalanceGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/getaddressbalance"));
    TArray<FString> QueryParams;
    if (Address.IsSet()) {
        QueryParams.Add(FString(TEXT("address=")) + ToUrlString(Address.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dGetaddressbalanceGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dGetaddressbalanceGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dGetaddressbalanceGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dGetblockheaderGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/getblockheader"));
    TArray<FString> QueryParams;
    if (Hash.IsSet()) {
        QueryParams.Add(FString(TEXT("hash=")) + ToUrlString(Hash.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dGetblockheaderGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dGetblockheaderGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    }
}

bool UnrealApi::Unity3dGetblockheaderGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dGetrawtransactionGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/getrawtransaction"));
    TArray<FString> QueryParams;
    if (Trxid.IsSet()) {
        QueryParams.Add(FString(TEXT("trxid=")) + ToUrlString(Trxid.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dGetrawtransactionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dGetrawtransactionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    }
}

bool UnrealApi::Unity3dGetrawtransactionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dGetutxosforaddressGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/getutxosforaddress"));
    TArray<FString> QueryParams;
    if (Address.IsSet()) {
        QueryParams.Add(FString(TEXT("address=")) + ToUrlString(Address.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dGetutxosforaddressGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dGetutxosforaddressGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    }
}

bool UnrealApi::Unity3dGetutxosforaddressGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dLocalCallPostRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/local-call"));
    return Path;
}

void UnrealApi::Unity3dLocalCallPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {TEXT("application/json-patch+json"), TEXT("application/json"), TEXT("text/json"), TEXT("application/*+json")};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("POST"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Body parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

        if (LocalCallContractRequest.IsSet()) {
            WriteJsonValue(Writer, LocalCallContractRequest.GetValue());
        }
        Writer->Close();

        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
        UE_LOG(LogStratisAPI, Error, TEXT("Body parameter (LocalCallContractRequest) was ignored, not supported in multipart form"));
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
        UE_LOG(LogStratisAPI, Error, TEXT("Body parameter (LocalCallContractRequest) was ignored, not supported in urlencoded requests"));
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dLocalCallPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    case 500:
        SetResponseString(TEXT("Server Error"));
        break;
    }
}

bool UnrealApi::Unity3dLocalCallPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dReceiptGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/receipt"));
    TArray<FString> QueryParams;
    if (TxHash.IsSet()) {
        QueryParams.Add(FString(TEXT("txHash=")) + ToUrlString(TxHash.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dReceiptGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dReceiptGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dReceiptGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dReceiptSearchGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/receipt-search"));
    TArray<FString> QueryParams;
    if (ContractAddress.IsSet()) {
        QueryParams.Add(FString(TEXT("contractAddress=")) + ToUrlString(ContractAddress.GetValue()));
    }
    if (EventName.IsSet()) {
        QueryParams.Add(FString(TEXT("eventName=")) + ToUrlString(EventName.GetValue()));
    }
    if (Topics.IsSet()) {
        QueryParams.Add(FString(TEXT("topics=")) + CollectionToUrlString_multi(Topics.GetValue(), TEXT("topics")));
    }
    if (FromBlock.IsSet()) {
        QueryParams.Add(FString(TEXT("fromBlock=")) + ToUrlString(FromBlock.GetValue()));
    }
    if (ToBlock.IsSet()) {
        QueryParams.Add(FString(TEXT("toBlock=")) + ToUrlString(ToBlock.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dReceiptSearchGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dReceiptSearchGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    }
}

bool UnrealApi::Unity3dReceiptSearchGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dReindexAllContractsGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/reindex-all-contracts"));
    return Path;
}

void UnrealApi::Unity3dReindexAllContractsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dReindexAllContractsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dReindexAllContractsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}

FString UnrealApi::Unity3dSendTransactionPostRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/send-transaction"));
    return Path;
}

void UnrealApi::Unity3dSendTransactionPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {TEXT("application/json-patch+json"), TEXT("application/json"), TEXT("text/json"), TEXT("application/*+json")};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("POST"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Body parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

        if (SendTransactionRequest.IsSet()) {
            WriteJsonValue(Writer, SendTransactionRequest.GetValue());
        }
        Writer->Close();

        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
        UE_LOG(LogTemp, Error, TEXT("Transaction Send Content: %s"), *JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
        UE_LOG(LogStratisAPI, Error, TEXT("Body parameter (SendTransactionRequest) was ignored, not supported in multipart form"));
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
        UE_LOG(LogStratisAPI, Error, TEXT("Body parameter (SendTransactionRequest) was ignored, not supported in urlencoded requests"));
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dSendTransactionPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    case 403:
        SetResponseString(TEXT("Forbidden"));
        break;
    case 500:
        SetResponseString(TEXT("Server Error"));
        break;
    }
}

bool UnrealApi::Unity3dSendTransactionPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dTipGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/tip"));
    return Path;
}

void UnrealApi::Unity3dTipGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dTipGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dTipGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dUnwatchNftContractGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/unwatch-nft-contract"));
    TArray<FString> QueryParams;
    if (ContractAddress.IsSet()) {
        QueryParams.Add(FString(TEXT("contractAddress=")) + ToUrlString(ContractAddress.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dUnwatchNftContractGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dUnwatchNftContractGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dUnwatchNftContractGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}

FString UnrealApi::Unity3dValidateaddressGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/validateaddress"));
    TArray<FString> QueryParams;
    if (Address.IsSet()) {
        QueryParams.Add(FString(TEXT("address=")) + ToUrlString(Address.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dValidateaddressGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dValidateaddressGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    }
}

bool UnrealApi::Unity3dValidateaddressGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return TryGetJsonValue(JsonValue, Content);
}

FString UnrealApi::Unity3dWatchNftContractGetRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/watch-nft-contract"));
    TArray<FString> QueryParams;
    if (ContractAddress.IsSet()) {
        QueryParams.Add(FString(TEXT("contractAddress=")) + ToUrlString(ContractAddress.GetValue()));
    }
    Path += TCHAR('?');
    Path += FString::Join(QueryParams, TEXT("&"));

    return Path;
}

void UnrealApi::Unity3dWatchNftContractGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("GET"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Form parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
        Writer->WriteObjectStart();
        Writer->WriteObjectEnd();
        Writer->Close();
        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dWatchNftContractGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dWatchNftContractGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}

FString UnrealApi::Unity3dWatchNftContractsPostRequest::ComputePath() const
{
    FString Path(TEXT("/Unity3d/watch-nft-contracts"));
    return Path;
}

void UnrealApi::Unity3dWatchNftContractsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
    static const TArray<FString> Consumes = {TEXT("application/json-patch+json"), TEXT("application/json"), TEXT("text/json"), TEXT("application/*+json")};
    // static const TArray<FString> Produces = { TEXT("text/plain"), TEXT("application/json"), TEXT("text/json") };

    HttpRequest->SetVerb(TEXT("POST"));

    if (Consumes.Num() == 0) {
        return;
    }

    // Default to Json Body request
    if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) {
        // Body parameters
        FString JsonBody;
        JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

        if (RequestBody.IsSet()) {
            WriteJsonValue(Writer, RequestBody.GetValue());
        }
        Writer->Close();

        HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        HttpRequest->SetContentAsString(JsonBody);
    } else if (Consumes.Contains(TEXT("multipart/form-data"))) {
        UE_LOG(LogStratisAPI, Error, TEXT("Body parameter (request_body) was ignored, not supported in multipart form"));
    } else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded"))) {
        UE_LOG(LogStratisAPI, Error, TEXT("Body parameter (request_body) was ignored, not supported in urlencoded requests"));
    } else {
        UE_LOG(LogStratisAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
    }
}

void UnrealApi::Unity3dWatchNftContractsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
    Response::SetHttpResponseCode(InHttpResponseCode);
    switch ((int)InHttpResponseCode) {
    case 200:
        SetResponseString(TEXT("Success"));
        break;
    case 400:
        SetResponseString(TEXT("Bad Request"));
        break;
    }
}

bool UnrealApi::Unity3dWatchNftContractsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}

} // namespace api
} // namespace stratis
